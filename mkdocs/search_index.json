{
    "docs": [
        {
            "location": "/",
            "text": "Overview\n\n\nPota is a \nfungeoidal\n programming language, largely inspired by \nBefunge\n.\n\n\nFeatures\n\n\n\n\nTwo-dimensional\n: Pota code is a two-dimensional character grid, where each character represents an instruction; instructions are executed by the Pointer as it moves in the corresponding cells. The code is not executed linearly, as the direction of the Pointer can be changed by Arrows and Mirrors.\n\n\nToroidal\n: the grid is topologically equivalent to a torus, meaning that the Pointer will wrap around when it reaches the (horizontal or vertical) end of the code.\n\n\nStack(s)-based\n: each Pointer comes with its own stack to store and retrieve data; new stacks can be created and old stacks merged as needed.\n\n\nString-based\n: instructions are strings, numbers are strings, strings are strings! There is no need to convert between data types when all you can deal with is a string.\n\n\nReflective\n: strings of arbitrary Pota code can be executed from inside the program itself, thanks to the \n`\n (Exec) instruction.\n\n\nSelf-modifying\n: a Pota program can read and modify its own code thanks to the \ng\n (Get) and \np\n (Put) instructions.\n\n\nFake multi-threading\n: more Pointers can be spawned with the \n (Spawn) instruction, but their actions are performed sequentially, so that there is no actual speedup.\n\n\n\n\n\"Hello Pota!\"\n\n\nBefore you start diving into the language, take a look at the classical \"Hello Pota!\" program:\n\n\nHello Pota!\no;\n\n\n\n\nInterpreter(s)\n\n\nThe official Pota interpreter can be found \nhere\n.\n\n\nThe C++ Pota interpreter (increased performance, decreased flexibility) can be found \nhere\n.\n\n\nDocumentation\n\n\n\n\nThe Language\n: comprehensive Pota documentation.",
            "title": "Overview"
        },
        {
            "location": "/#overview",
            "text": "Pota is a  fungeoidal  programming language, largely inspired by  Befunge .",
            "title": "Overview"
        },
        {
            "location": "/#features",
            "text": "Two-dimensional : Pota code is a two-dimensional character grid, where each character represents an instruction; instructions are executed by the Pointer as it moves in the corresponding cells. The code is not executed linearly, as the direction of the Pointer can be changed by Arrows and Mirrors.  Toroidal : the grid is topologically equivalent to a torus, meaning that the Pointer will wrap around when it reaches the (horizontal or vertical) end of the code.  Stack(s)-based : each Pointer comes with its own stack to store and retrieve data; new stacks can be created and old stacks merged as needed.  String-based : instructions are strings, numbers are strings, strings are strings! There is no need to convert between data types when all you can deal with is a string.  Reflective : strings of arbitrary Pota code can be executed from inside the program itself, thanks to the  `  (Exec) instruction.  Self-modifying : a Pota program can read and modify its own code thanks to the  g  (Get) and  p  (Put) instructions.  Fake multi-threading : more Pointers can be spawned with the   (Spawn) instruction, but their actions are performed sequentially, so that there is no actual speedup.",
            "title": "Features"
        },
        {
            "location": "/#hello-pota",
            "text": "Before you start diving into the language, take a look at the classical \"Hello Pota!\" program:  Hello Pota! o;",
            "title": "\"Hello Pota!\""
        },
        {
            "location": "/#interpreters",
            "text": "The official Pota interpreter can be found  here .  The C++ Pota interpreter (increased performance, decreased flexibility) can be found  here .",
            "title": "Interpreter(s)"
        },
        {
            "location": "/#documentation",
            "text": "The Language : comprehensive Pota documentation.",
            "title": "Documentation"
        },
        {
            "location": "/Documentation/language/",
            "text": "The Language\n\n\nCode\n\n\nPota source files have the extension \n.pota\n.\n\n\nPota source code can be viewed as a 2D grid, where each cell stores a character; empty cells act as if they contained an empty space. Cells are referenced to with pairs of coordinates \n(x,y)\n where \nx\n stands for \"character\" and \ny\n stands for \"line\". \nx\n and \ny\n are both 0\nindexed; \n(0,0)\n is the top\nleft cell. Note that if the first line begins with \n#!\n it is ignored by the interpreter in order to allow shebang\ned scripts; in this case the second line has index 0 instead of the first.\n\n\nFor instance, if the source code is the following\n\n\nv\n^\n\n\n\n\n\nthen cell \n(0,0)\n contains \n, cell \n(1,0)\n contains \nv\n, cell \n(1,1)\n contains \n and cell \n(0,1)\n contains \n^\n.\n\n\nWhen the program starts, all the cells contain at most one character, but nothing stops them from storing strings of arbitrary length later in the execution: in Pota, characters are just strings of length 1, and the code can be modified at runtime. So, in general, a cell contains a string of 0 or more characters.\n\nNote that an empty cell and a cell storing an empty string are different things: the former is a cell whose value was not specified in the code, and thus defaults to containing an empty space \n\" \"\n, while the latter \ndoes\n store an empty string \n\"\"\n.\n\n\nPointers\n\n\nPointers are the objects that execute instructions found in the source code, and they do this by physically moving on the code itself.\n\n\nThe behaviour of a Pointer is determined by the following variables.\n\n\n\n\nId\n: a unique identifier of the Pointer, used to send messages between Pointers.\n\n\nPosition\n: a pair of \n(x,y)\n coordinates representing the location of the Pointer.\n\n\nDirection\n: one of \n(1,0)\n (right), \n(-1,0)\n (left), \n(0,1)\n (down), \n(0,-1)\n (up)\n\n\nStacks\n: a stack of stacks; it is the main storage system for the Pointer; many instructions interact in different ways with it, but only the topmost stack can be accessed; when we say \"the stack\", we actually refer to the topmost stack in the stack of stacks; recall that the only data type in Pota is \nstring\n, so stacks can only hold strings.\n\n\nMessages\n: a FIFO queue that collects messages sent by other Pointers (or possibly by the Pointer to itself).\n\n\nInstructions\n: a queue that stores instructions to be executed and supports insertion to both front and back and deletion from the front.\n\n\n\n\nProgram Execution\n\n\nAt the beginning of the program execution, a single Pointer is created at \n(0,0)\n facing right.\n\nWhen a Pointer is created, all the characters in the string contained in the cell the Pointer is standing in are pushed, in order, to the back of the instructions queue. Then, until the Pointer is alive, it repeatedly performs the following operations:\n\n\n\n\nif the instructions queue is empty, it moves one cell in the direction it is facing; then, all the characters in the string contained in the cell the Pointer is standing in are pushed, in order, to the back of the instructions queue;\n\n\notherwise, a single instruction is popped from the front of the instructions queue and executed.\n\n\n\n\nIf a Pointer is on an empty cell and sees nothing but empty cells ahead of it, it will eventually wrap around to the other side of the code; the exact moment when this happens is implementation\ndefined, though.\n\nIf, instead, a Pointer is on the negative side of the code (either \nx\n0\n or \ny\n0\n), then it will immediately wrap around, without even reading the instructions in the cell it was on.\n\n\nWhen a Pointer executes the \n;\n (Die) instruction it immediately dies (stops being alive).\n\nThe execution ends when there are no more Pointers alive.\n\n\nIf there are multiple Pointers alive at the same time, the order of execution is unspecified. Thus, a program should never rely on a Pointer performing some operations before another Pointer, unless that program appropriately makes use of \n#\n (Wait) and \n@\n (Send) instructions for communication between Pointers.\n\n\nInstructions\n\n\nHere is the complete list of Pota instructions; see below for more detailed descriptions.\n\n\n\n\n\n\n\n\nInstruction\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n \n v ^\n\n\nArrows\n\n\nChange the direction of the Pointer.\n\n\n\n\n\n\n/ \\ x\n\n\nMirrors\n\n\nChange the direction of the Pointer depending on the current direction. \nx\n chooses a random direction.\n\n\n\n\n\n\n!\n\n\nSkip\n\n\nSkip the next instruction/cell.\n\n\n\n\n\n\n?\n\n\nCondSkip\n\n\nConditional skip: pop \nx\n from the stack and skip the next instruction/cell if \nx\n is anything but \n\"0\"\n.\n\n\n\n\n\n\nt\n\n\nTrampoline\n\n\nPop \nx\n from the stack and skip the next \nx\n instructions/cells.\n\n\n\n\n\n\n\" '\n\n\nStringMode\n\n\nStart/end string mode. When in string mode, the Pointer pushes a string containing the instructions it finds to the stack instead of executing them.\n\n\n\n\n\n\n0 1 2 3 4\n  \n5 6 7 8 9\n\n\nDigits\n\n\nPush the corresponding digit to the stack.\n\n\n\n\n\n\nw\n\n\nWhere\n\n\nIf \n(x,y)\n is the position of the Pointer, push \nx\n and \ny\n to the stack.\n\n\n\n\n\n\nj\n\n\nJump\n\n\nPop \ny\n and \nx\n from the stack and jump to \n(x,y)\n.\n\n\n\n\n\n\n_\n\n\nNegate\n\n\nPop \nx\n from the stack, then push \n-x\n.\n\n\n\n\n\n\n+ - * | %\n\n\nArith\n\n\nPop \ny\n and \nx\n from the stack, then push \nx operator y\n; \n|\n is integer division, \n%\n is remainder.\n\n\n\n\n\n\n.\n\n\nConcat\n\n\nPop \ny\n and \nx\n from the stack, then push their string\nwise concatenation \nx+y\n.\n\n\n\n\n\n\n= ( ) [ ]\n\n\nCmp\n\n\nPop \ny\n and \nx\n from the stack, then push \n\"1\"\n if \nx operator y\n holds, otherwise push \n\"0\"\n. \n=\n is string\nwise equality, \n(\n and \n)\n are string\nwise lexicographical comparisons (respectively smaller than, larger than), \n[\n and \n]\n are integer comparisons (respectively smaller than, larger than).\n\n\n\n\n\n\n,\n\n\nDuplicate\n\n\nPop \nx\n from the stack, then push \nx\n and \nx\n.\n\n\n\n\n\n\n~\n\n\nPop\n\n\nPop \nx\n from the stack.\n\n\n\n\n\n\n$\n\n\nSwap\n\n\nPop \ny\n and \nx\n from the stack, then push \ny\n and \nx\n.\n\n\n\n\n\n\n:\n\n\nFlatten'\n\n\nConcatenate all the strings in the stack in a single string.\n\n\n\n\n\n\nf\n\n\nFlatten\n\n\nPop \nx\n from the stack, then concatenate all the string in the stack using \nx\n as separator.\n\n\n\n\n\n\n{ }\n\n\nRotate\n\n\nRotate the stack respectively to the left and to the right.\n\n\n\n\n\n\nr\n\n\nReverse\n\n\nReverse the stack.\n\n\n\n\n\n\nn\n\n\nNew\n\n\nPop \nx\n from the stack, then split the stack in two, creating a new one: the last \nx\n elements of the old stack, preserving their order, become the elements of the new stack.\n\n\n\n\n\n\nm\n\n\nMerge\n\n\nMerge the stack with the stack underlying; if the current stack is the only one, then empty it.\n\n\n\n\n\n\nd\n\n\nSDuplicate\n\n\nCreate a new stack identical to the underlying one.\n\n\n\n\n\n\ne\n\n\nExplode\n\n\nPop \nx\n from the stack, then add a new stack containing the characters of \nx\n, in order.\n\n\n\n\n\n\ns\n\n\nSplit\n\n\nPop \ny\n and \nx\n from the stack, then add a new stack containing the result of splitting \nx\n with \ny\n as separator.\n\n\n\n\n\n\nl\n\n\nLength\n\n\nPush the length of the stack to the stack.\n\n\n\n\n\n\n`\n\n\nExec\n\n\nPop \nx\n from the stack, then push all the characters of \nx\n to the front of the instructions queue, so that the corresponding instructions are executed in order.\n\n\n\n\n\n\ng\n\n\nGet\n\n\nPop \ny\n and \nx\n from the stack, then push the value of cell \n(x,y)\n.\n\n\n\n\n\n\np\n\n\nPut\n\n\nPop \ny\n, \nx\n and \nv\n from the stack and set cell \n(x, y)\n to \nv\n.\n\n\n\n\n\n\n\n\nSpawn\n\n\nPop \nx\n from the stack, then create a new Pointer in the cell in front of the current position of the Pointer; the new Pointer will have the same direction as the old one, and \nx\n elements will be transferred from the stack of the old Pointer to that of the new one.\n\n\n\n\n\n\n#\n\n\nWait\n\n\nWait until the messages queue is not empty, then push one message to the stack, removing it from the queue.\n\n\n\n\n\n\n@\n\n\nSend\n\n\nPop \ny\n and \nx\n from the stack, then send the message \nx\n to Pointer with id \ny\n.\n\n\n\n\n\n\ny\n\n\nId\n\n\nPush the id of the Pointer to the stack.\n\n\n\n\n\n\nc\n\n\nChr\n\n\nPop \nx\n from the stack, then push the character with ASCII value \nx\n.\n\n\n\n\n\n\na\n\n\nOrd\n\n\nPop \nx\n from the stack, then push the ASCII value of \nx\n.\n\n\n\n\n\n\ni\n\n\nIn\n\n\nRead one character from \nstdin\n and push it to the stack.\n\n\n\n\n\n\no\n\n\nOut\n\n\nPop \nx\n from the stack and print it.\n\n\n\n\n\n\n;\n\n\nDie\n\n\nStop being alive.\n\n\n\n\n\n\n\n\nArrows\n\n\nWhen one of the instructions \n \n v ^\n is executed, the direction of the Pointer changes immediately.\n\n\n\n\n: right \n(1,0)\n\n\n: left \n(-1,0)\n\n\nv\n: down \n(0,1)\n\n\n^\n: up \n(0,-1)\n\n\n\n\nFor example, consider the following code:\n\n\nv\n^\n\n\n\n\nAt the beginning of the execution, a Pointer is created ad \n(0,0)\n, facing right, but it immediately executes \nv\n, so its directions becomes down. The Pointer then moves to \n(0,1)\n, where it executes \n^\n, so that it faces up. With the next move, the Pointer goes to \n(0,0)\n again, where it executes \nv\n and changes its direction to down. This sequence of actions is clearly repeated indefinitely, while the Pointer endlessly bounces from \n(0,0)\n to \n(0,1)\n and back.\n\n\nMirrors\n\n\nWhen one of the instructions \n/ \\ x\n is executed, the direction of the Pointer changes immediately.\n\n\nx\n selects a random direction.\n\nThe other mirrors behave as follows; if the direction was \n(u,v)\n, it becomes\n\n\n\n\n/\n: \n(-v,-u)\n\n\n\\\n: \n(v,u)\n\n\n\n\nFor example, consider the following code:\n\n\n/\\\n\\/\n\n\n\n\nThe Pointer starts at \n(0,0)\n facing right, but it immediately bounces against \n/\n and starts moving up. Remember that Pota code grid is toroidal, so the Pointer wraps around to somewhere on the first column and keeps moving up, until it bounces against \n\\\n in \n(0,1)\n. Try to follow the path of the Pointer as it moves left, wraps around, bounces against \n/\n in \n(1,1)\n, moves down, wraps around again, bounces against \n\\\n in \n(1,0)\n, moves right and wraps around to \n(0,0)\n, finding itself stuck in an endless loop.\n\n\nSkip, CondSkip, Trampoline\n\n\n!\n (Skip) instruction has the following effect:\n\n\n\n\nif the instructions queue is not empty, discard the next instruction (pop from the front without executing anything);\n\n\nif the instructions queue is empty, ignore \nall\n the instructions found in the next cell.\n\n\n\n\nConsider the following examples:\n\n\n!;0o\n\n\n\n\nThe Pointer starts at \n(0,0)\n facing right, it executes \n!\n and thus skips \n;\n. It then executes \n0\n, pushing \n\"0\"\n to the stack, and \no\n, popping \n\"0\"\n from the stack and outputting it, before wrapping around to \n(0,0)\n and repeating.\n\n\n!;0o\n`;\n\n\n\n\nIn this example the Pointer enters string mode and pushes \n\"!;0o\"\n to the stack. When \n`\n is executed, instructions \n! ; 0 o\n are pushed to the instructions queue: \n!\n is executed, \n;\n is skipped, \n0\n and \no\n are executed (so \n\"0\"\n is printed). Then, the Pointer moves to \n(7,0)\n, executes \n;\n and dies.\n\n\n?\n (CondSkip) is equivalent to the following:\n\n\n\n\nPop \nx\n from the stack.\n\n\nIf \nx\n is \n\"0\"\n do nothing, otherwise execute \n!\n.\n\n\n\n\nt\n (Trampoline) is an enhanced \n!\n: it pops \nx\n from the stack, then skips the next \nx\n \"actions\", where an \"action\" is one of\n\n\n\n\nexecuting an instruction from the instructions queue\n\n\npushing the content of a cell to the instructions queue\n\n\n\n\nFor example, consider the following code\n\n\n02t;\n`;o;\n\n\n\n\nThe Pointer pushes \n\"02t;\"\n to the stack, then executes it thanks to \n`\n in \n(6,0)\n: \n\"0\"\n is pushed, then \n\"2\"\n, then \nt\n is executed, so the next \n2\n actions are skipped (the \n;\n in the string and the \n;\n in \n(7,0)\n. Finally, \n\"0\"\n is printed and the Pointer dies.\n\n\nStringMode\n\n\nWhen the Pointer executed one of \n\" '\n it enters string mode: until a matching quote is found, all the characters encountered are added verbatim to a temporary string, that is pushed to the stack when the Pointer exits string mode.\n\nFor example, consider the following code:\n\n\n123abc;'\no;\n\n\n\n\nIn \n(0,0)\n the Pointer enter string mode, which lasts until \n(9,0)\n; here, string \n\"123abc;'\"\n is pushed to the stack, and is printed when \no\n is executed. Note that \n123abc;\n are not executed as instructions, and even \n'\n is skipped, since it does not match the \n\"\n opening quote.\n\n\nConsider the following more complicated example:\n\n\no;\n30p\n\n\n\n\nAt the beginning, the Pointer enters string mode, reads \n\"o;\"\n, and exits string mode at \n(3,0)\n; so, at \n(3,0)\n, the stack looks like this: \n[\"o;\"]\n. Then \n3\n and \n0\n are executed; when \np\n is executed, the stack looks like this \n[\"o;\", \"3\", \"0\"]\n, so value \n\"o;\"\n is put at \n(3,0)\n, where the \n\"\n was. The Pointer wraps around and, at \n(0,0)\n, enters string mode again: it reads \n\"o\"\n, \n\";\"\n, then in \n(3,0)\n it reads \n\"o;\"\n, then \n\"3\"\n, \n\"0\"\n, \n\"p\"\n; finally, it wraps around and exits string mode at \n(0,0)\n. At this moment, the stack looks like this: \n[\"o;o;30p\"]\n (plus an arbitrary number of spaces that we will ignore for the moment). The Pointer moves to \n(1,0)\n, where it executes \no\n (printing \n\"o;o;30p\"\n), then it executes \n;\n and dies.\n\n\nSince in Pota numbers are strings, string mode is useful for pushing long numbers to the stack. For instance, the code \n\"123\"\"456\"+o;\n will output \n\"579\"\n.\n\n\nJump\n\n\nj\n (Jump) lets the Pointer jump anywhere in the code grid, by popping \ny\n and \nx\n from the stack and teleporting to \n(x,y)\n.\n\nThere are two things to bear in mind:\n\n\n\n\nthe Pointer is not allowed to jump to \n(x,y)\n if either \nx\n0\n or \ny\n0\n\n\nthe Pointer should jump to the cell \nbefore\n the one containing the instructions you want to execute, as the Pointer will move before adding new instructions to the instructions queue\n\n\n\n\nCmp\n\n\n=\n is \nstring-wise\n equality: for instance, \n\"1\"\"01\"=o;\n will output \n\"0\"\n, since \n\"1\"!=\"01\"\n, although \n1=01\n.\n\n\nThe difference between \n(\n and \n[\n is subtle, but important. The former performs string\nwise lexicographical comparison, while the latter is for integer comparison: for instance, \n\"12\"\"2\"(o;\n will output \n\"1\"\n, since \"12\" is lexicographically smaller than \n\"2\"\n, while \n\"12\"\"2\"[o;\n will output \n\"0\"\n, since \n12\n is larger than \n2\n.\n\n\nSometimes it is necessary to perform boolean algebra with values obtained from Cmp instructions. Pota does not have native logical operators, but those can be easily implemented.\n\n\n\n\n1$-\n is equivalent to logical not.\n\n\n*\n is equivalent to logical and.\n\n\n+0]\n is equivalent to logical or, although if you want to use it in conjunction with \n?\n (CondSkip) you may as well write \n+?\n instead of \n+0]?\n.\n\n\n+1=\n is equivalent to logical xor.\n\n\n\n\nFlatten', Flatten, Rotate, Reverse\n\n\nThese instructions affect the entire stack. Let us see what they do with some examples.\n\n\n:\n (Flatten') concatenates all the string in the stack into a single string. For instance, if the stack is \n[\"abc\", \"def\", \"0\"]\n, after executing \n:\n it will look like this: \n[\"abcdef0\"]\n.\n\nWhen used in conjunction with \n~\n (Pop), \n:\n can be used to clear the stack (whatever the stack looks like, after executing \n:~\n it will be empty).\n\n\nf\n (Flatten) is the general version of \n:\n, as it accepts the separator as an argument. \nf\n pops \nx\n from the stack and uses it as a separator to concatenate all the strings in the stack. For instance, if the stack is \n[\"ab\", \"cd\", \"ef\", \", \"]\n, after executing \nf\n it will look like this: \n[\"ab, cd, ef\"]\n.\n\n\n:\n is equivalent to \n\"\"f\n.\n\n\n{\n and \n}\n (Rotate) rotate the stack, respectively, left and right. For instance, if the stack is \n[\"1\", \"2\", \"3\", \"4\"]\n, after executing \n{\n it will look like this: \n[\"2\", \"3\", \"4\", \"1\"]\n. After executing \n}\n, instead, it will look like this: \n[\"4\", \"1\", \"2\", \"3\"]\n.\n\n\nr\n (Reverse) reverses the stack. For instance, if the stack is \n[\"1\", \"2\", \"3\", \"4\"]\n, after executing \nr\n it will look like this: \n[\"4\", \"3\", \"2\", \"1\"]\n.\n\n\nNew, Merge, SDuplicate, Explode, Split\n\n\nPointers support multiple stacks, although only the topmost one can ever be accessed.\n\n\nn\n (New) splits the topmost stack: \nx\n is popped, then the last \nx\n elements of the stack are moved to a new stack, which is placed \"above\" the old one. For instance, if the stack is \n[\"a\", \"b\", \"c\", \"2\"]\n, when \nn\n is executed \n\"2\"\n is popped, then the last \n2\n elements are moved to a new stack. In the end there will be two stacks, and they will look like this: \n[\"a\"] [\"b\", \"c\"]\n.\n\n\nm\n (Merge) merges the two topomost stacks. For instance, if there are three stacks \n[\"a\"] [\"b\", \"c\"] [\"d\", \"e\"]\n, after executing \nm\n there will be two, looking like this: \n[\"a\"] [\"b\", \"c\", \"d\", \"e\"]\n.\n\nIf there is only one stack, \nm\n will clear it.\n\n\nd\n (SDuplicate) creates a new stack identical to the topmost one and puts the new stack \"above\" the old one (or the other way around, not that it really matters). For instance, if there are two stacks \n[\"a\", \"b\"] [\"c\", \"d\"]\n, aftere executing \nd\n there will be three, looking like this: \n[\"a\", \"b\"] [\"c\", \"d\"] [\"c\", \"d\"]\n.\n\n\ne\n (Explode) pops \nx\n, then creates a new stack containing \nx\n \"exploded\" to characters. For instance, if the stack is \n[\"ab\", \"cdefg\"]\n, after executing \ne\n there will be two stacks, looking like this: \n[\"ab\"] [\"c\", \"d\", \"e\", \"f\", \"g\"]\n.\n\n\ns\n (Split) pops \ny\n and \nx\n, then creates a new stack containing \nx\n \"split\" using \ny\n as a separator. For instance, if the stack is \n[\"a\nb\ncd\", \"\n\"]\n, after executing \ns\n there will be two stacks, looking like this \n[] [\"a\", \"b\", \"\", \"cd\"]\n.\n\nMake sure \ny\n is not the empty string or the program will crash.\n\n\nGet, Put\n\n\nPota programs have the ability to read and modify their own source code. There are two main reasons for doing this.\n\n\n\n\nStorage\n: regions of the source code that are never visited by Pointers can be used to store and retrieve data. Negative regions of the code (either \nx\n0\n or \ny\n0\n) are well suited for this purpose, since a Pointer cannot visit them.\n\n\nExecution\n: regions of the source code that are eventually visited by Pointers can be modified to cleverly alter their behaviour in potentially infinitely many ways.",
            "title": "The Language"
        },
        {
            "location": "/Documentation/language/#the-language",
            "text": "",
            "title": "The Language"
        },
        {
            "location": "/Documentation/language/#code",
            "text": "Pota source files have the extension  .pota .  Pota source code can be viewed as a 2D grid, where each cell stores a character; empty cells act as if they contained an empty space. Cells are referenced to with pairs of coordinates  (x,y)  where  x  stands for \"character\" and  y  stands for \"line\".  x  and  y  are both 0 indexed;  (0,0)  is the top left cell. Note that if the first line begins with  #!  it is ignored by the interpreter in order to allow shebang ed scripts; in this case the second line has index 0 instead of the first.  For instance, if the source code is the following  v\n^   then cell  (0,0)  contains  , cell  (1,0)  contains  v , cell  (1,1)  contains   and cell  (0,1)  contains  ^ .  When the program starts, all the cells contain at most one character, but nothing stops them from storing strings of arbitrary length later in the execution: in Pota, characters are just strings of length 1, and the code can be modified at runtime. So, in general, a cell contains a string of 0 or more characters. \nNote that an empty cell and a cell storing an empty string are different things: the former is a cell whose value was not specified in the code, and thus defaults to containing an empty space  \" \" , while the latter  does  store an empty string  \"\" .",
            "title": "Code"
        },
        {
            "location": "/Documentation/language/#pointers",
            "text": "Pointers are the objects that execute instructions found in the source code, and they do this by physically moving on the code itself.  The behaviour of a Pointer is determined by the following variables.   Id : a unique identifier of the Pointer, used to send messages between Pointers.  Position : a pair of  (x,y)  coordinates representing the location of the Pointer.  Direction : one of  (1,0)  (right),  (-1,0)  (left),  (0,1)  (down),  (0,-1)  (up)  Stacks : a stack of stacks; it is the main storage system for the Pointer; many instructions interact in different ways with it, but only the topmost stack can be accessed; when we say \"the stack\", we actually refer to the topmost stack in the stack of stacks; recall that the only data type in Pota is  string , so stacks can only hold strings.  Messages : a FIFO queue that collects messages sent by other Pointers (or possibly by the Pointer to itself).  Instructions : a queue that stores instructions to be executed and supports insertion to both front and back and deletion from the front.",
            "title": "Pointers"
        },
        {
            "location": "/Documentation/language/#program-execution",
            "text": "At the beginning of the program execution, a single Pointer is created at  (0,0)  facing right. \nWhen a Pointer is created, all the characters in the string contained in the cell the Pointer is standing in are pushed, in order, to the back of the instructions queue. Then, until the Pointer is alive, it repeatedly performs the following operations:   if the instructions queue is empty, it moves one cell in the direction it is facing; then, all the characters in the string contained in the cell the Pointer is standing in are pushed, in order, to the back of the instructions queue;  otherwise, a single instruction is popped from the front of the instructions queue and executed.   If a Pointer is on an empty cell and sees nothing but empty cells ahead of it, it will eventually wrap around to the other side of the code; the exact moment when this happens is implementation defined, though. \nIf, instead, a Pointer is on the negative side of the code (either  x 0  or  y 0 ), then it will immediately wrap around, without even reading the instructions in the cell it was on.  When a Pointer executes the  ;  (Die) instruction it immediately dies (stops being alive). \nThe execution ends when there are no more Pointers alive.  If there are multiple Pointers alive at the same time, the order of execution is unspecified. Thus, a program should never rely on a Pointer performing some operations before another Pointer, unless that program appropriately makes use of  #  (Wait) and  @  (Send) instructions for communication between Pointers.",
            "title": "Program Execution"
        },
        {
            "location": "/Documentation/language/#instructions",
            "text": "Here is the complete list of Pota instructions; see below for more detailed descriptions.     Instruction  Name  Description         v ^  Arrows  Change the direction of the Pointer.    / \\ x  Mirrors  Change the direction of the Pointer depending on the current direction.  x  chooses a random direction.    !  Skip  Skip the next instruction/cell.    ?  CondSkip  Conditional skip: pop  x  from the stack and skip the next instruction/cell if  x  is anything but  \"0\" .    t  Trampoline  Pop  x  from the stack and skip the next  x  instructions/cells.    \" '  StringMode  Start/end string mode. When in string mode, the Pointer pushes a string containing the instructions it finds to the stack instead of executing them.    0 1 2 3 4    5 6 7 8 9  Digits  Push the corresponding digit to the stack.    w  Where  If  (x,y)  is the position of the Pointer, push  x  and  y  to the stack.    j  Jump  Pop  y  and  x  from the stack and jump to  (x,y) .    _  Negate  Pop  x  from the stack, then push  -x .    + - * | %  Arith  Pop  y  and  x  from the stack, then push  x operator y ;  |  is integer division,  %  is remainder.    .  Concat  Pop  y  and  x  from the stack, then push their string wise concatenation  x+y .    = ( ) [ ]  Cmp  Pop  y  and  x  from the stack, then push  \"1\"  if  x operator y  holds, otherwise push  \"0\" .  =  is string wise equality,  (  and  )  are string wise lexicographical comparisons (respectively smaller than, larger than),  [  and  ]  are integer comparisons (respectively smaller than, larger than).    ,  Duplicate  Pop  x  from the stack, then push  x  and  x .    ~  Pop  Pop  x  from the stack.    $  Swap  Pop  y  and  x  from the stack, then push  y  and  x .    :  Flatten'  Concatenate all the strings in the stack in a single string.    f  Flatten  Pop  x  from the stack, then concatenate all the string in the stack using  x  as separator.    { }  Rotate  Rotate the stack respectively to the left and to the right.    r  Reverse  Reverse the stack.    n  New  Pop  x  from the stack, then split the stack in two, creating a new one: the last  x  elements of the old stack, preserving their order, become the elements of the new stack.    m  Merge  Merge the stack with the stack underlying; if the current stack is the only one, then empty it.    d  SDuplicate  Create a new stack identical to the underlying one.    e  Explode  Pop  x  from the stack, then add a new stack containing the characters of  x , in order.    s  Split  Pop  y  and  x  from the stack, then add a new stack containing the result of splitting  x  with  y  as separator.    l  Length  Push the length of the stack to the stack.    `  Exec  Pop  x  from the stack, then push all the characters of  x  to the front of the instructions queue, so that the corresponding instructions are executed in order.    g  Get  Pop  y  and  x  from the stack, then push the value of cell  (x,y) .    p  Put  Pop  y ,  x  and  v  from the stack and set cell  (x, y)  to  v .     Spawn  Pop  x  from the stack, then create a new Pointer in the cell in front of the current position of the Pointer; the new Pointer will have the same direction as the old one, and  x  elements will be transferred from the stack of the old Pointer to that of the new one.    #  Wait  Wait until the messages queue is not empty, then push one message to the stack, removing it from the queue.    @  Send  Pop  y  and  x  from the stack, then send the message  x  to Pointer with id  y .    y  Id  Push the id of the Pointer to the stack.    c  Chr  Pop  x  from the stack, then push the character with ASCII value  x .    a  Ord  Pop  x  from the stack, then push the ASCII value of  x .    i  In  Read one character from  stdin  and push it to the stack.    o  Out  Pop  x  from the stack and print it.    ;  Die  Stop being alive.",
            "title": "Instructions"
        },
        {
            "location": "/Documentation/language/#arrows",
            "text": "When one of the instructions     v ^  is executed, the direction of the Pointer changes immediately.   : right  (1,0)  : left  (-1,0)  v : down  (0,1)  ^ : up  (0,-1)   For example, consider the following code:  v\n^  At the beginning of the execution, a Pointer is created ad  (0,0) , facing right, but it immediately executes  v , so its directions becomes down. The Pointer then moves to  (0,1) , where it executes  ^ , so that it faces up. With the next move, the Pointer goes to  (0,0)  again, where it executes  v  and changes its direction to down. This sequence of actions is clearly repeated indefinitely, while the Pointer endlessly bounces from  (0,0)  to  (0,1)  and back.",
            "title": "Arrows"
        },
        {
            "location": "/Documentation/language/#mirrors",
            "text": "When one of the instructions  / \\ x  is executed, the direction of the Pointer changes immediately.  x  selects a random direction. \nThe other mirrors behave as follows; if the direction was  (u,v) , it becomes   / :  (-v,-u)  \\ :  (v,u)   For example, consider the following code:  /\\\n\\/  The Pointer starts at  (0,0)  facing right, but it immediately bounces against  /  and starts moving up. Remember that Pota code grid is toroidal, so the Pointer wraps around to somewhere on the first column and keeps moving up, until it bounces against  \\  in  (0,1) . Try to follow the path of the Pointer as it moves left, wraps around, bounces against  /  in  (1,1) , moves down, wraps around again, bounces against  \\  in  (1,0) , moves right and wraps around to  (0,0) , finding itself stuck in an endless loop.",
            "title": "Mirrors"
        },
        {
            "location": "/Documentation/language/#skip-condskip-trampoline",
            "text": "!  (Skip) instruction has the following effect:   if the instructions queue is not empty, discard the next instruction (pop from the front without executing anything);  if the instructions queue is empty, ignore  all  the instructions found in the next cell.   Consider the following examples:  !;0o  The Pointer starts at  (0,0)  facing right, it executes  !  and thus skips  ; . It then executes  0 , pushing  \"0\"  to the stack, and  o , popping  \"0\"  from the stack and outputting it, before wrapping around to  (0,0)  and repeating.  !;0o `;  In this example the Pointer enters string mode and pushes  \"!;0o\"  to the stack. When  `  is executed, instructions  ! ; 0 o  are pushed to the instructions queue:  !  is executed,  ;  is skipped,  0  and  o  are executed (so  \"0\"  is printed). Then, the Pointer moves to  (7,0) , executes  ;  and dies.  ?  (CondSkip) is equivalent to the following:   Pop  x  from the stack.  If  x  is  \"0\"  do nothing, otherwise execute  ! .   t  (Trampoline) is an enhanced  ! : it pops  x  from the stack, then skips the next  x  \"actions\", where an \"action\" is one of   executing an instruction from the instructions queue  pushing the content of a cell to the instructions queue   For example, consider the following code  02t; `;o;  The Pointer pushes  \"02t;\"  to the stack, then executes it thanks to  `  in  (6,0) :  \"0\"  is pushed, then  \"2\" , then  t  is executed, so the next  2  actions are skipped (the  ;  in the string and the  ;  in  (7,0) . Finally,  \"0\"  is printed and the Pointer dies.",
            "title": "Skip, CondSkip, Trampoline"
        },
        {
            "location": "/Documentation/language/#stringmode",
            "text": "When the Pointer executed one of  \" '  it enters string mode: until a matching quote is found, all the characters encountered are added verbatim to a temporary string, that is pushed to the stack when the Pointer exits string mode. \nFor example, consider the following code:  123abc;' o;  In  (0,0)  the Pointer enter string mode, which lasts until  (9,0) ; here, string  \"123abc;'\"  is pushed to the stack, and is printed when  o  is executed. Note that  123abc;  are not executed as instructions, and even  '  is skipped, since it does not match the  \"  opening quote.  Consider the following more complicated example:  o; 30p  At the beginning, the Pointer enters string mode, reads  \"o;\" , and exits string mode at  (3,0) ; so, at  (3,0) , the stack looks like this:  [\"o;\"] . Then  3  and  0  are executed; when  p  is executed, the stack looks like this  [\"o;\", \"3\", \"0\"] , so value  \"o;\"  is put at  (3,0) , where the  \"  was. The Pointer wraps around and, at  (0,0) , enters string mode again: it reads  \"o\" ,  \";\" , then in  (3,0)  it reads  \"o;\" , then  \"3\" ,  \"0\" ,  \"p\" ; finally, it wraps around and exits string mode at  (0,0) . At this moment, the stack looks like this:  [\"o;o;30p\"]  (plus an arbitrary number of spaces that we will ignore for the moment). The Pointer moves to  (1,0) , where it executes  o  (printing  \"o;o;30p\" ), then it executes  ;  and dies.  Since in Pota numbers are strings, string mode is useful for pushing long numbers to the stack. For instance, the code  \"123\"\"456\"+o;  will output  \"579\" .",
            "title": "StringMode"
        },
        {
            "location": "/Documentation/language/#jump",
            "text": "j  (Jump) lets the Pointer jump anywhere in the code grid, by popping  y  and  x  from the stack and teleporting to  (x,y) . \nThere are two things to bear in mind:   the Pointer is not allowed to jump to  (x,y)  if either  x 0  or  y 0  the Pointer should jump to the cell  before  the one containing the instructions you want to execute, as the Pointer will move before adding new instructions to the instructions queue",
            "title": "Jump"
        },
        {
            "location": "/Documentation/language/#cmp",
            "text": "=  is  string-wise  equality: for instance,  \"1\"\"01\"=o;  will output  \"0\" , since  \"1\"!=\"01\" , although  1=01 .  The difference between  (  and  [  is subtle, but important. The former performs string wise lexicographical comparison, while the latter is for integer comparison: for instance,  \"12\"\"2\"(o;  will output  \"1\" , since \"12\" is lexicographically smaller than  \"2\" , while  \"12\"\"2\"[o;  will output  \"0\" , since  12  is larger than  2 .  Sometimes it is necessary to perform boolean algebra with values obtained from Cmp instructions. Pota does not have native logical operators, but those can be easily implemented.   1$-  is equivalent to logical not.  *  is equivalent to logical and.  +0]  is equivalent to logical or, although if you want to use it in conjunction with  ?  (CondSkip) you may as well write  +?  instead of  +0]? .  +1=  is equivalent to logical xor.",
            "title": "Cmp"
        },
        {
            "location": "/Documentation/language/#flatten-flatten-rotate-reverse",
            "text": "These instructions affect the entire stack. Let us see what they do with some examples.  :  (Flatten') concatenates all the string in the stack into a single string. For instance, if the stack is  [\"abc\", \"def\", \"0\"] , after executing  :  it will look like this:  [\"abcdef0\"] . \nWhen used in conjunction with  ~  (Pop),  :  can be used to clear the stack (whatever the stack looks like, after executing  :~  it will be empty).  f  (Flatten) is the general version of  : , as it accepts the separator as an argument.  f  pops  x  from the stack and uses it as a separator to concatenate all the strings in the stack. For instance, if the stack is  [\"ab\", \"cd\", \"ef\", \", \"] , after executing  f  it will look like this:  [\"ab, cd, ef\"] .  :  is equivalent to  \"\"f .  {  and  }  (Rotate) rotate the stack, respectively, left and right. For instance, if the stack is  [\"1\", \"2\", \"3\", \"4\"] , after executing  {  it will look like this:  [\"2\", \"3\", \"4\", \"1\"] . After executing  } , instead, it will look like this:  [\"4\", \"1\", \"2\", \"3\"] .  r  (Reverse) reverses the stack. For instance, if the stack is  [\"1\", \"2\", \"3\", \"4\"] , after executing  r  it will look like this:  [\"4\", \"3\", \"2\", \"1\"] .",
            "title": "Flatten', Flatten, Rotate, Reverse"
        },
        {
            "location": "/Documentation/language/#new-merge-sduplicate-explode-split",
            "text": "Pointers support multiple stacks, although only the topmost one can ever be accessed.  n  (New) splits the topmost stack:  x  is popped, then the last  x  elements of the stack are moved to a new stack, which is placed \"above\" the old one. For instance, if the stack is  [\"a\", \"b\", \"c\", \"2\"] , when  n  is executed  \"2\"  is popped, then the last  2  elements are moved to a new stack. In the end there will be two stacks, and they will look like this:  [\"a\"] [\"b\", \"c\"] .  m  (Merge) merges the two topomost stacks. For instance, if there are three stacks  [\"a\"] [\"b\", \"c\"] [\"d\", \"e\"] , after executing  m  there will be two, looking like this:  [\"a\"] [\"b\", \"c\", \"d\", \"e\"] . \nIf there is only one stack,  m  will clear it.  d  (SDuplicate) creates a new stack identical to the topmost one and puts the new stack \"above\" the old one (or the other way around, not that it really matters). For instance, if there are two stacks  [\"a\", \"b\"] [\"c\", \"d\"] , aftere executing  d  there will be three, looking like this:  [\"a\", \"b\"] [\"c\", \"d\"] [\"c\", \"d\"] .  e  (Explode) pops  x , then creates a new stack containing  x  \"exploded\" to characters. For instance, if the stack is  [\"ab\", \"cdefg\"] , after executing  e  there will be two stacks, looking like this:  [\"ab\"] [\"c\", \"d\", \"e\", \"f\", \"g\"] .  s  (Split) pops  y  and  x , then creates a new stack containing  x  \"split\" using  y  as a separator. For instance, if the stack is  [\"a b cd\", \" \"] , after executing  s  there will be two stacks, looking like this  [] [\"a\", \"b\", \"\", \"cd\"] . \nMake sure  y  is not the empty string or the program will crash.",
            "title": "New, Merge, SDuplicate, Explode, Split"
        },
        {
            "location": "/Documentation/language/#get-put",
            "text": "Pota programs have the ability to read and modify their own source code. There are two main reasons for doing this.   Storage : regions of the source code that are never visited by Pointers can be used to store and retrieve data. Negative regions of the code (either  x 0  or  y 0 ) are well suited for this purpose, since a Pointer cannot visit them.  Execution : regions of the source code that are eventually visited by Pointers can be modified to cleverly alter their behaviour in potentially infinitely many ways.",
            "title": "Get, Put"
        }
    ]
}